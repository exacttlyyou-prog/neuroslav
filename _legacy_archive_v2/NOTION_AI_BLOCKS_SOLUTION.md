# Технический отчет: Стратегии интеграции и извлечения данных из Notion AI в корпоративных средах

**Январь 2026 года**

## 1. Введение: Эволюция экосистемы Notion и проблемы программного доступа

По состоянию на январь 2026 года платформа Notion трансформировалась из простого инструмента для ведения заметок в операционную систему для хранения корпоративных знаний. Однако внедрение функций генеративного искусственного интеллекта, в частности блока «AI Meeting Notes» (Заметки о встречах с ИИ), создало существенный технологический разрыв между возможностями пользовательского интерфейса и доступностью данных через публичный API. Для инженеров по автоматизации и разработчиков интеграций это создает критическую проблему: данные, генерируемые ИИ, часто остаются непрозрачными для стандартных методов запросов REST API, возвращая ошибки валидации или пустые объекты.

В данном отчете проводится глубокий анализ архитектурных ограничений Notion API версии 2022-06-28 (и последующих бета-версий) в контексте работы с блоками ИИ. Мы рассмотрим причины возникновения ошибок типа «incorrect block» и представим детально проработанные стратегии обхода этих ограничений. Основное внимание уделяется двум методикам: использованию Model Context Protocol (MCP) в качестве моста для преобразования данных и реализации фонового парсера (Background Parser) на базе Playwright для эмуляции пользовательской сессии.

### 1.1 Архитектурный конфликт: Статические блоки против Динамических контейнеров

Чтобы понять природу проблем, с которыми сталкиваются разработчики в 2026 году, необходимо проанализировать фундаментальную структуру данных Notion. Традиционно страница Notion представляет собой дерево блоков (Block Tree), где каждый параграф, заголовок или список является отдельным объектом с детерминированной схемой данных.

Однако блок «AI Meeting Notes» представляет собой принципиально иную сущность. Это динамический контейнер, содержимое которого (транскрипция, резюме, список задач) генерируется асинхронно на стороне сервера Notion AI и часто хранится в отдельном микросервисе, отличном от основной базы данных блоков. Когда стандартный REST API пытается сериализовать этот контейнер в JSON-ответ, он сталкивается с отсутствием соответствующей публичной схемы. В результате API возвращает ошибку validation_error или помечает блок как unsupported, так как не может сопоставить внутреннюю структуру данных с доступными типами блоков (paragraph, callout и т.д.).

### 1.2 Стратегические векторы решения

Для решения задачи программного доступа к этим данным в отчете предлагаются два архитектурных подхода:

**Стратегия A: Использование MCP-сервера.** Model Context Protocol позволяет взаимодействовать с Notion через специализированный слой абстракции. Инструмент fetch, встроенный в MCP-сервер, преобразует дерево блоков страницы в Markdown. В процессе этой конверсии сложные, неподдерживаемые API блоки часто редуцируются до их текстового представления, что позволяет извлечь содержимое резюме встречи, минуя строгую валидацию схемы JSON.

**Стратегия B: Фоновый парсер (Headless Browser).** В случаях, когда API полностью блокирует доступ к блоку (возвращает пустой массив потомков), применяется автоматизация браузера. Этот метод требует сложной реализации аутентификации («программный логин»), так как Notion использует продвинутые методы защиты от ботов. В отчете детально разбирается паттерн «Replay Session» (повторное использование сессии) для обхода CAPTCHA и двухфакторной аутентификации.

## 2. Анализ проблемы: Ошибка "Incorrect Block" и ограничения API

При попытке обратиться к блоку AI Meeting Notes через стандартный эндпоинт GET /v1/blocks/{block_id}/children, разработчики неизбежно сталкиваются с ошибками. Это не баг в коде интеграции, а системное ограничение текущей версии API.

### 2.1 Анатомия ошибки валидации

Ошибка incorrect block или validation_error, возникающая при попытке взаимодействия с блоками ИИ, указывает на то, что API-шлюз Notion получает запрос на обработку типа данных, который не внесен в публичный манифест типов ("allowlist").

| Тип ошибки | HTTP Код | Описание проблемы | Причина возникновения |
|------------|----------|-------------------|----------------------|
| object_not_found | 404 | Блок не найден или нет доступа. | Часто возникает не из-за отсутствия блока, а из-за того, что токен интеграции не имеет доступа к конкретной странице, даже если он имеет доступ к рабочему пространству. |
| validation_error | 400 | Тело запроса не соответствует схеме. | Попытка обновить или создать блок ИИ через API. Схема ai_block закрыта для записи. |
| unsupported_block | 200 (в теле) | Блок возвращается с типом unsupported. | API видит блок, но не умеет его сериализовать. Поле type равно unsupported, содержимое отсутствует. |
| incorrect_block | 400 | Неверный идентификатор или тип операции. | Попытка применить операцию append_children к блоку, который технически не поддерживает вложенность в публичной модели данных, хотя визуально имеет контент. |

### 2.2 Недоступность содержимого транскрипции

Блок AI Meeting Notes визуально выглядит как раскрывающийся список (toggle), содержащий транскрипцию и сгенерированное саммари. Однако, с точки зрения API, связь между родительским блоком (контейнером ИИ) и дочерними текстовыми блоками часто разрывается или скрывается. Исследования показывают, что попытка запросить children у такого блока возвращает пустой список, даже если визуально текст присутствует. Это связано с тем, что контент подгружается динамически (Lazy Loading) на клиенте и не хранится как прямые потомки в графе блоков, доступном через публичный API.

В сообществе разработчиков (Zapier, Reddit, GitHub Issues) консенсус сводится к тому, что прямой доступ через REST API к этим блокам невозможен по состоянию на январь 2026 года без использования обходных путей ("workarounds").

## 3. Стратегия A: Работа с Notion MCP (Model Context Protocol)

Model Context Protocol (MCP) — это новый стандарт взаимодействия между LLM (например, Claude, OpenAI) и внешними инструментами. Notion выпустил официальный MCP-сервер (makenotion/notion-mcp-server), который действует как прокси между агентом ИИ и API Notion.

### 3.1 Преимущество MCP перед REST API

Ключевое отличие MCP заключается в том, как он обрабатывает данные. REST API возвращает строгий JSON. MCP-сервер Notion, напротив, ориентирован на предоставление контекста для LLM. Инструмент notion_fetch (или retrieve_page в некоторых форках) внутри себя реализует логику конвертации страницы в Markdown.

**Механизм обхода ошибки:**
Конвертер Markdown, встроенный в MCP-сервер, написан таким образом, чтобы быть устойчивым к ошибкам. Встречая "неподдерживаемый" блок (например, AI Meeting Notes), он часто пытается извлечь из него доступное текстовое представление (plain_text) или рендерит его как цитату/код, вместо того чтобы выбрасывать исключение. Это позволяет "вытащить" текст саммари, который был бы недоступен в "сыром" JSON-ответе.

### 3.2 Устранение проблем запуска MCP ("Notion MCP не запускается")

Пользователь указал на проблему с запуском MCP. В январе 2026 года экосистема Node.js и MCP имеет специфические требования, нарушение которых ведет к "тихому" падению сервера.

#### 3.2.1 Критические требования к среде (Environment)

**Версия Node.js:** Абсолютно критично использование Node.js v18.0.0 или выше (рекомендуется v20 LTS). MCP SDK активно использует нативный fetch API и другие возможности, отсутствующие в v14/v16. Использование старой версии Node приведет к ошибкам синтаксиса при запуске.

**Аутентификация (Token vs OAuth):**
- Для локальной разработки и скриптов необходимо использовать Internal Integration Token (начинается с secret_).
- OAuth токены (начинаются с ntn_) требуют сложной процедуры обмена токенами ("token exchange flow") и чаще используются в SaaS-решениях.

**Важно:** Токен должен быть передан через переменные окружения (env), а не через аргументы командной строки, чтобы избежать утечек в логах процессов.

#### 3.2.2 Конфигурация клиента (Claude Desktop / Cursor)

Одной из самых частых причин ошибки "mcp не запускается" является неправильная конфигурация путей в файле настроек (например, claude_desktop_config.json). Относительные пути (например, ./node_modules/...) часто не разрешаются корректно, так как рабочая директория (CWD) агента может отличаться от ожидаемой.

**Эталонная конфигурация для 2026 года:**

```json
{
  "mcpServers": {
    "notion": {
      "command": "node",
      "args": ["/absolute/path/to/node_modules/@notionhq/notion-mcp-server/dist/index.js"],
      "env": {
        "NOTION_TOKEN": "secret_YOUR_INTEGRATION_TOKEN_HERE"
      }
    }
  }
}
```

**Примечание:** Обратите внимание на использование абсолютного пути. Если используется npx, убедитесь, что npx находится в PATH среды, в которой запускается агент.

### 3.3 Инструкция по использованию инструмента Fetch

После успешного запуска сервера, агент должен использовать инструмент notion_fetch для получения данных.

- **Входные данные:** page_id (UUID страницы встречи).
- **Ожидаемый результат:** Строка в формате Markdown.
- **Постобработка:** Поскольку AI Meeting Notes преобразуются в Markdown, они часто обрамляются тегами `<summary>` или заголовками `# Summary`. Агент должен использовать регулярные выражения для парсинга этого текста.

## 4. Стратегия B: Фоновый Парсер (Background Parser) на Playwright

Если метод MCP не срабатывает (например, блок пуст даже в Markdown), единственным надежным способом остается эмуляция пользователя через Headless Browser.

### 4.1 Проблема "Программного логина" в Notion

Пользователь задал вопрос: "Как правильно логиниться в ноушне программно?".

**Ответ эксперта:** Прямой программный вход (ввод логина и пароля в скрипте) в 2026 году невозможен и крайне ненадежен.

**Причины:**
- **Magic Links:** Notion часто требует подтверждения через email ("Magic Link"), что невозможно автоматизировать без доступа к почтовому ящику.
- **SSO (Google/Apple):** Кнопка "Continue with Google" открывает окна с динамической защитой от ботов, которые блокируют автоматизированные драйверы (Selenium/Playwright).
- **Bot Detection:** Cloudflare и внутренние системы защиты Notion анализируют поведение курсора и цифровой отпечаток браузера.

### 4.2 Решение: Паттерн "Session Replay" (Сохранение состояния)

Единственно верный способ "программного" входа — это использование предварительно сохраненной сессии (куки и LocalStorage).

#### 4.2.1 Архитектура аутентификации

Процесс разделяется на две фазы: "Ручная подготовка" и "Автоматическое исполнение".

**Фаза 1: Ручная генерация слепка сессии (выполняется человеком один раз)**
1. Запускается скрипт Playwright в режиме headless: false (с видимым окном).
2. Скрипт переходит на notion.so/login.
3. Человек вручную вводит данные, проходит 2FA, нажимает "Continue with Google".
4. После успешной загрузки рабочего пространства скрипт сохраняет состояние хранилища (storageState) в JSON-файл.
5. Этот файл (auth.json) содержит валидные токены сессии (token_v2), которые живут длительное время.

**Фаза 2: Работа робота (выполняется программно)**
1. Фоновый парсер запускается.
2. Вместо ввода пароля, он инъектирует auth.json в контекст браузера при инициализации.
3. Notion считает, что это тот же самый браузер, и пускает пользователя без лишних вопросов.

### 4.3 Технические нюансы парсинга блоков ИИ

После входа в систему возникает проблема виртуализации (Virtualization) и отложенной загрузки (Lazy Loading). Notion — это сложное React-приложение. Блоки, которые находятся ниже видимой области экрана ("below the fold"), физически отсутствуют в DOM-дереве.

**Алгоритм скроллинга:**
Парсер не может просто загрузить страницу и искать текст. Он должен эмулировать скроллинг:
1. Прокрутить вниз на высоту окна (window.scrollTo).
2. Подождать сетевой активности (загрузка чанков данных).
3. Повторять, пока нужный селектор (например, содержащий текст "AI Summary") не появится в DOM.

**Селекторы:**
- Нельзя полагаться на автогенерируемые классы (например, .css-1a2b3c), так как они меняются при каждом деплое Notion. Необходимо использовать атрибуты данных:
  - `div[data-block-id]` — надежный идентификатор блока.
  - Поиск по тексту: `locator('div').filter({ hasText: 'AI Summary' })`.

## 5. Подробная инструкция для Код-Ассистента

Ниже приведена детализированная спецификация (промпт), которую необходимо передать ИИ-ассистенту (Cursor, Windsurf, Custom Agent) для реализации решения. Эта инструкция объединяет обе стратегии и учитывает все технические нюансы, описанные выше.

### Спецификация Задачи для Код-Ассистента

**Роль:** Senior DevOps & Automation Engineer.

**Задача:** Реализовать систему извлечения данных из блоков "AI Meeting Notes" в Notion, обходя ошибку "Incorrect Block".

**Контекст:** Стандартный API не поддерживает этот тип данных. Требуется гибридное решение.

### Часть 1: Настройка MCP-сервера (Приоритет 1 - API метод)

**Конфигурация окружения:**
1. Создай файл конфигурации для MCP-клиента (например, для Claude Desktop или Cursor).
2. **Важно:** Используй абсолютный путь к исполняемому файлу сервера (index.js).
3. **Важно:** Передай NOTION_TOKEN (токен интеграции) исключительно через объект env, а не как аргумент командной строки.
4. Проверь совместимость: Скрипт установки должен проверять версию Node.js (node -v). Если версия ниже 18, выводи критическую ошибку.

**Скрипт-клиент (TypeScript):**
1. Напиши скрипт, использующий MCP SDK для подключения к серверу.
2. Вызови инструмент notion_fetch (или retrieve_page) для целевой страницы.
3. **Парсинг Markdown:** Полученный Markdown-текст необходимо проанализировать. Напиши Regex, который ищет секцию, начинающуюся с `# Summary` (или тега `<summary>`) и захватывает текст до следующего заголовка.
4. **Обработка ошибок:** Если в ответе содержится текст `` или если секция саммари пуста, скрипт должен вернуть статус FALLBACK_REQUIRED.

### Часть 2: Фоновый Парсер на Playwright (Приоритет 2 - Fallback метод)

Если метод MCP вернул FALLBACK_REQUIRED, запускается этот модуль.

**Модуль Аутентификации (auth-setup.ts):**
1. Напиши утилитарный скрипт для ручного создания сессии.
2. Запусти браузер: `chromium.launch({ headless: false })`.
3. Перейди на https://www.notion.so/login.
4. Ожидай, пока URL не изменится на https://www.notion.so/my-workspace... (индикатор успешного входа пользователем).
5. Сохрани состояние: `await context.storageState({ path: 'auth.json' });`.
6. Добавь auth.json в .gitignore.

**Модуль Скрапинга (scraper.ts):**
1. Используй паттерн Singleton для браузера, чтобы не перезапускать его для каждой страницы.
2. Загрузи контекст: `browser.newContext({ storageState: 'auth.json' })`.
3. Перейди на целевую страницу.
4. **Логика Виртуализации:** Реализуй функцию `smartScroll()`. Она должна прокручивать страницу вниз шагами по 800px и ждать 500мс, пока в DOM не появится элемент с текстом "AI Summary" или "Summary".
5. **Селекторы:** Используй `page.locator('div[data-block-id]').filter({ hasText: /AI Summary|Summary/i })`.
6. Извлеки текст через `.innerText()`.

**Защита от обнаружения:**
1. Используй плагин playwright-extra и puppeteer-extra-plugin-stealth для скрытия признаков автоматизации.
2. Установи реальный User-Agent (Chrome on macOS/Windows).

## 6. Сравнительный анализ подходов

В таблице ниже представлено сравнение двух предложенных методов для принятия решения о внедрении.

| Характеристика | Notion MCP (API/Markdown) | Playwright (Фоновый парсер) |
|----------------|---------------------------|----------------------------|
| Надежность | Высокая (официальные каналы) | Средняя (зависит от верстки UI) |
| Сложность настройки | Низкая (JSON конфиг + Токен) | Высокая (Docker, управление сессиями) |
| Доступ к AI-блокам | Ограниченный (зависит от конвертера) | Полный (визуальный рендеринг) |
| Аутентификация | Токен интеграции (стабильно) | Сессионные куки (требуют обновления) |
| Скорость работы | Быстро (HTTP запросы) | Медленно (рендеринг браузера) |
| Риск блокировки | Нулевой | Присутствует (Rate limits, Bot detection) |

## 7. Заключение

Работа с Notion API в январе 2026 года требует гибкости и использования гибридных подходов. Прямая интеграция для "AI Meeting Notes" невозможна из-за ограничений публичной схемы данных ("Incorrect Block").

Оптимальная стратегия заключается в использовании Notion MCP сервера как первичного инструмента. Его способность преобразовывать сложные структуры блоков в плоский Markdown позволяет "обойти" строгую типизацию API и извлечь текстовое содержимое саммари.

В случаях, когда MCP оказывается бессилен, необходимо переходить к фоновому парсингу через Playwright. Ключом к успеху здесь является отказ от попыток запрограммировать процесс ввода пароля в пользу инъекции предварительно сохраненных сессионных токенов (storageState). Это обеспечивает стабильный доступ к данным, защищенным 2FA и SSO, и позволяет эмулировать поведение реального пользователя для считывания динамически подгружаемого контента ИИ.
